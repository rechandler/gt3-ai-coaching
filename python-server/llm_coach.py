#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
LLM-Powered GT3 Racing Coach
Provides natural language coaching using LLM integration
"""

import time
import logging
import json
import requests
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from collections import deque

logger = logging.getLogger(__name__)

@dataclass
class LLMCoachingMessage:
    """A coaching message generated by LLM"""
    message: str
    category: str
    priority: int
    confidence: float
    context: str
    explanation: str

class LLMRacingCoach:
    """LLM-powered racing coach that provides contextual, natural coaching"""
    
    def __init__(self, api_key: Optional[str] = None, model: str = "gpt-3.5-turbo"):
        self.api_key = api_key or "your-openai-api-key-here"  # Replace with actual key
        self.model = model
        self.enabled = bool(api_key and api_key != "your-openai-api-key-here")
        
        # Track context for better coaching
        self.recent_telemetry = deque(maxlen=50)  # Last 5 seconds at 10Hz
        self.corner_history = {}
        self.lap_data = []
        self.current_track = None
        self.current_car = None
        self.session_start = time.time()
        
        # Message cooldowns to prevent spam
        self.last_message_time = {}
        self.message_cooldown = 8  # seconds
        
        logger.info(f"LLM Racing Coach initialized (enabled: {self.enabled})")
    
    def update_session_info(self, track_name: str, car_name: str):
        """Update session information"""
        self.current_track = track_name
        self.current_car = car_name
        logger.info(f"Session updated: {car_name} at {track_name}")
    
    def analyze_driving(self, telemetry: Dict[str, Any]) -> Optional[LLMCoachingMessage]:
        """Analyze current driving and generate contextual coaching if needed"""
        if not self.enabled:
            return None
            
        self.recent_telemetry.append({
            **telemetry,
            'timestamp': time.time()
        })
        
        # Look for coaching opportunities
        coaching_context = self._detect_coaching_moments(telemetry)
        if coaching_context:
            return self._generate_coaching_message(coaching_context, telemetry)
        
        return None
    
    def _detect_coaching_moments(self, telemetry: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Detect when coaching would be helpful"""
        if len(self.recent_telemetry) < 10:
            return None
            
        current_time = time.time()
        
        # Heavy braking moment
        if telemetry.get('brake', 0) > 50 and telemetry.get('speed', 0) > 60:
            return {
                'type': 'braking',
                'severity': 'heavy' if telemetry.get('brake', 0) > 80 else 'moderate',
                'context': self._get_track_context(telemetry),
                'recent_data': list(self.recent_telemetry)[-5:]
            }
        
        # Aggressive throttle application
        if len(self.recent_telemetry) >= 2:
            prev_throttle = self.recent_telemetry[-2].get('throttle', 0)
            curr_throttle = telemetry.get('throttle', 0)
            if curr_throttle - prev_throttle > 30 and telemetry.get('speed', 0) < 60:
                return {
                    'type': 'throttle',
                    'severity': 'aggressive',
                    'context': self._get_track_context(telemetry),
                    'recent_data': list(self.recent_telemetry)[-5:]
                }
        
        # Corner exit analysis
        if self._is_corner_exit(telemetry):
            return {
                'type': 'corner_exit',
                'context': self._get_track_context(telemetry),
                'recent_data': list(self.recent_telemetry)[-10:]
            }
        
        # High speed with steering input (potential oversteer/understeer)
        steering = abs(telemetry.get('steerAngle', 0))
        if steering > 15 and telemetry.get('speed', 0) > 80:
            return {
                'type': 'handling',
                'severity': 'oversteer' if telemetry.get('throttle', 0) > 60 else 'understeer',
                'context': self._get_track_context(telemetry),
                'recent_data': list(self.recent_telemetry)[-5:]
            }
        
        return None
    
    def _get_track_context(self, telemetry: Dict[str, Any]) -> str:
        """Determine what part of track we're on"""
        speed = telemetry.get('speed', 0)
        brake = telemetry.get('brake', 0)
        throttle = telemetry.get('throttle', 0)
        
        if brake > 30:
            return "braking zone"
        elif speed < 60 and throttle > 40:
            return "corner exit"
        elif speed > 120:
            return "high speed section"
        elif speed < 60:
            return "tight corner"
        else:
            return "mid-speed corner"
    
    def _is_corner_exit(self, telemetry: Dict[str, Any]) -> bool:
        """Detect if we're exiting a corner"""
        if len(self.recent_telemetry) < 5:
            return False
            
        # Speed increasing with throttle application
        recent_speeds = [t.get('speed', 0) for t in list(self.recent_telemetry)[-5:]]
        if recent_speeds[-1] > recent_speeds[0] + 10 and telemetry.get('throttle', 0) > 50:
            return True
        return False
    
    def _generate_coaching_message(self, context: Dict[str, Any], current_telemetry: Dict[str, Any]) -> Optional[LLMCoachingMessage]:
        """Generate LLM coaching message"""
        message_key = f"{context['type']}_{context.get('severity', 'normal')}"
        current_time = time.time()
        
        # Check cooldown
        if message_key in self.last_message_time:
            if current_time - self.last_message_time[message_key] < self.message_cooldown:
                return None
        
        try:
            prompt = self._build_coaching_prompt(context, current_telemetry)
            response = self._call_llm(prompt)
            
            if response:
                self.last_message_time[message_key] = current_time
                return self._parse_coaching_response(response, context)
                
        except Exception as e:
            logger.error(f"LLM coaching generation failed: {e}")
        
        return None
    
    def _build_coaching_prompt(self, context: Dict[str, Any], telemetry: Dict[str, Any]) -> str:
        """Build coaching prompt for LLM"""
        context_type = context['type']
        track_context = context.get('context', 'unknown section')
        
        base_prompt = f"""You are an expert GT3 racing coach providing real-time coaching to a driver. Be specific, concise, and actionable.

Current situation:
- Track: {self.current_track or 'Unknown Track'}
- Car: {self.current_car or 'GT3 Car'}
- Location: {track_context}
- Speed: {telemetry.get('speed', 0):.0f} mph
- Brake: {telemetry.get('brake', 0):.0f}%
- Throttle: {telemetry.get('throttle', 0):.0f}%
- Steering: {abs(telemetry.get('steerAngle', 0)):.1f}°

"""

        if context_type == 'braking':
            brake_pressure = telemetry.get('brake', 0)
            speed = telemetry.get('speed', 0)
            prompt = base_prompt + f"""The driver just applied {brake_pressure:.0f}% brake pressure at {speed:.0f} mph in the {track_context}.

Provide specific coaching about their braking technique. Consider:
- If they're braking too late/early for this speed
- If brake pressure is appropriate
- How to improve their braking for this specific corner

Respond with a natural coaching message under 25 words. Be specific about what corner or section this is if possible."""

        elif context_type == 'throttle':
            throttle_delta = context.get('throttle_change', 0)
            prompt = base_prompt + f"""The driver just applied aggressive throttle ({telemetry.get('throttle', 0):.0f}%) at low speed in the {track_context}.

Provide specific coaching about throttle control. Consider:
- Risk of wheelspin at this speed
- How to apply throttle more progressively
- Corner exit optimization

Respond with a natural coaching message under 25 words."""

        elif context_type == 'corner_exit':
            recent_speeds = [t.get('speed', 0) for t in context['recent_data']]
            prompt = base_prompt + f"""The driver is exiting a corner with speeds: {recent_speeds[-3:]} mph progression.

Analyze their corner exit technique and provide specific coaching:
- Are they getting on throttle at the right time?
- Is their acceleration smooth and progressive?
- How can they improve exit speed?

Respond with a natural coaching message under 25 words."""

        elif context_type == 'handling':
            severity = context.get('severity', 'neutral')
            steering = abs(telemetry.get('steerAngle', 0))
            prompt = base_prompt + f"""The driver has {steering:.1f}° of steering input at {telemetry.get('speed', 0):.0f} mph, showing signs of {severity}.

Provide specific handling advice:
- How to correct the current situation
- Technique to prevent this issue
- Specific input adjustments needed

Respond with a natural coaching message under 25 words."""

        else:
            prompt = base_prompt + f"""Analyze the current driving situation and provide relevant coaching advice.

Respond with a natural coaching message under 25 words."""

        return prompt

    def _call_llm(self, prompt: str) -> Optional[str]:
        """Call OpenAI API for coaching generation"""
        if not self.enabled:
            return None
            
        try:
            headers = {
                'Authorization': f'Bearer {self.api_key}',
                'Content-Type': 'application/json'
            }
            
            data = {
                'model': self.model,
                'messages': [
                    {
                        'role': 'system',
                        'content': 'You are a professional GT3 racing coach. Provide concise, actionable coaching advice.'
                    },
                    {
                        'role': 'user', 
                        'content': prompt
                    }
                ],
                'max_tokens': 100,
                'temperature': 0.7
            }
            
            response = requests.post(
                'https://api.openai.com/v1/chat/completions',
                headers=headers,
                json=data,
                timeout=5
            )
            
            if response.status_code == 200:
                result = response.json()
                return result['choices'][0]['message']['content'].strip()
            else:
                logger.error(f"OpenAI API error: {response.status_code}")
                return None
                
        except Exception as e:
            logger.error(f"LLM API call failed: {e}")
            return None
    
    def _parse_coaching_response(self, response: str, context: Dict[str, Any]) -> LLMCoachingMessage:
        """Parse LLM response into coaching message"""
        category_map = {
            'braking': 'braking',
            'throttle': 'throttle', 
            'corner_exit': 'racing_line',
            'handling': 'technique'
        }
        
        priority_map = {
            'heavy': 6,
            'aggressive': 5,
            'moderate': 4,
            'normal': 3
        }
        
        category = category_map.get(context['type'], 'technique')
        priority = priority_map.get(context.get('severity', 'normal'), 3)
        
        return LLMCoachingMessage(
            message=response,
            category=category,
            priority=priority,
            confidence=85,
            context=context.get('context', ''),
            explanation=f"LLM analysis of {context['type']} situation"
        )

# Legacy compatibility wrapper
class CoachingMessage:
    """Legacy coaching message format"""
    def __init__(self, message: str, category: str, priority: int, confidence: float, data_source: str):
        self.message = message
        self.category = category
        self.priority = priority
        self.confidence = confidence
        self.data_source = data_source
